# 点云数据处理与数据集构建设计

## 1. 数据概述

当前数据集结构：
- 物体目录：`000` 到 `087`（共88个物体）
- 每个物体有多个位姿：`pose_000` 到 `pose_023`（最多24个位姿）
- 每个位姿下有多个抓取结果，包含以下数据：
  - 触觉点云：`xxx_tactile_left.pcd` 和 `xxx_tactile_right.pcd`
  - 局部截取的物体点云：`xxx_cropped_object.pcd`
  - 局部截取的表面点云：`xxx_cropped_surface.pcd`
  - 更大范围的上下文表面点云：`xxx_cropped_surface_context.pcd`
  - 抓取位姿信息：`xxx_tactile_grasp_pose.json`

## 2. 数据处理目标

1. 将点云数据从PCD格式转换为NumPy数组格式，便于深度学习算法处理
2. 构建结构化的训练、验证和测试数据集
3. 设计适合点云补全任务的数据存储格式
4. 确保数据集支持多尺度点云补全任务

## 3. 数据集划分策略

### 3.1 划分方案

建议采用以下划分方案：

1. **按物体ID划分**（推荐）：
   - 训练集：物体000-069（约80%）
   - 验证集：物体070-079（约10%）
   - 测试集：物体080-087（约10%）
   
   这种划分方式可以测试模型对未见过物体的泛化能力，符合实际应用场景。

2. **按位姿划分**（可选）：
   - 对每个物体，使用位姿000-018作为训练集（约80%）
   - 对每个物体，使用位姿019-021作为验证集（约10%）
   - 对每个物体，使用位姿022-023作为测试集（约10%）
   
   这种划分方式可以测试模型对已知物体新位姿的泛化能力。

3. **混合划分**（进阶）：
   - 创建一个"seen objects"测试集：已知物体的未见过位姿
   - 创建一个"unseen objects"测试集：完全未见过的物体
   
   这种划分可以全面评估模型的不同类型泛化能力。

### 3.2 数据增强

为增强模型的鲁棒性，建议在训练过程中应用以下数据增强技术：

1. 随机旋转（绕Z轴）
2. 随机抖动（小幅度平移）
3. 随机降采样或上采样
4. 随机添加噪声
5. 随机遮挡（模拟传感器盲区）

## 4. 数据存储格式设计

### 4.1 基本存储结构

建议采用以下NumPy数组格式存储数据：

```
dataset/
├── train/
│   ├── input/
│   │   ├── tactile_and_object_000000.npy  # 合并的触觉点云和物体点云
│   │   ├── tactile_and_object_000001.npy
│   │   └── ...
│   ├── gt_local/
│   │   ├── surface_local_000000.npy  # 局部表面点云（GT）
│   │   ├── surface_local_000001.npy
│   │   └── ...
│   └── gt_global/
│       ├── surface_global_000000.npy  # 全局表面点云（GT）
│       ├── surface_global_000001.npy
│       └── ...
├── val/
│   ├── input/
│   ├── gt_local/
│   └── gt_global/
└── test/
    ├── input/
    ├── gt_local/
    └── gt_global/
```

### 4.2 元数据存储

为每个样本创建元数据文件，记录样本来源和处理信息：

```
dataset/
├── train_metadata.json
├── val_metadata.json
└── test_metadata.json
```

元数据格式示例：
```json
{
  "000000": {
    "object_id": "023",
    "pose_id": "pose_005",
    "grasp_id": "023_grasp_002",
    "original_path": "/path/to/original/data",
    "num_points": {
      "tactile_left": 512,
      "tactile_right": 498,
      "object": 1024,
      "surface_local": 2048,
      "surface_global": 4096
    },
    "transforms_applied": ["rotation", "jitter"]
  },
  "000001": {
    ...
  }
}
```

## 5. 点云处理步骤

### 5.1 点云标准化

1. **点云居中**：将每个点云的质心移动到原点
2. **点云缩放**：将点云缩放到[-1, 1]的标准范围内
3. **点云采样**：使用FPS（最远点采样）或随机采样确保点云具有固定数量的点

建议的采样密度：
- 触觉点云（左）：512点
- 触觉点云（右）：512点
- 物体点云：1024点
- 局部表面点云：2048点
- 全局表面点云：4096点

### 5.2 点云合并与对齐

1. 将左右触觉点云与物体点云合并为输入点云
2. 确保所有点云使用相同的坐标系
3. 使用抓取位姿信息确保点云对齐

## 6. 数据处理实现

建议创建以下脚本：

1. `dataset_convert.py`：将PCD文件转换为NumPy格式
2. `dataset_split.py`：划分训练、验证和测试集
3. `dataset_normalize.py`：标准化和采样点云
4. `dataset_augment.py`：实现数据增强功能
5. `dataset_loader.py`：创建PyTorch或TensorFlow数据加载器

## 7. 数据集使用建议

### 7.1 多尺度训练策略

考虑到点云补全任务的多尺度特性，建议采用以下训练策略：

1. **分阶段训练**：
   - 第一阶段：仅使用局部GT进行训练
   - 第二阶段：使用局部GT和全局GT联合训练

2. **多任务学习**：
   - 同时预测局部补全和全局补全
   - 使用加权损失函数平衡两个任务

### 7.2 评估指标

建议使用以下指标评估点云补全质量：

1. **Chamfer Distance (CD)**：测量两个点云之间的平均最近点距离
2. **Earth Mover's Distance (EMD)**：测量两个点云之间的最优传输距离
3. **F-Score**：在不同阈值下的精度和召回率的调和平均
4. **物体特征保留率**：评估补全点云保留原始物体特征的程度

## 8. 实施计划

1. **第一阶段**：数据转换与预处理
   - 实现PCD到NumPy的转换
   - 实现点云标准化和采样

2. **第二阶段**：数据集构建
   - 实现数据集划分
   - 创建元数据文件

3. **第三阶段**：数据加载器开发
   - 实现数据增强
   - 创建批处理功能

4. **第四阶段**：验证与优化
   - 测试数据加载性能
   - 优化存储格式和处理流程

## 9. 注意事项

1. 确保处理后的点云保持原始拓扑结构
2. 考虑存储空间与处理效率的平衡
3. 为大型数据集实现分批处理功能
4. 保留原始数据的备份
5. 考虑使用HDF5或TFRecord等格式提高大数据集的读取效率
